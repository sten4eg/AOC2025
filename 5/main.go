package main

import (
	"fmt"
	"strconv"
	"strings"
)

var g = "213743501161200-213743501161200\n221359789392478-222960432116258\n553905700373062-561794342755365\n388351876706917-388578461376678\n263685821321516-270464997549766\n384957836075964-385057316204755\n86932924454422-88726115602910\n64713316693400-65189382496202\n68179610157787-68454649435444\n143154545648377-145980913110898\n390250299542523-390843409397977\n392162789636707-394167531415509\n467795551515047-469145316638624\n73412860995201-78319783604609\n174577844186025-180222947242739\n34889394659118-37852045203256\n506719917120116-506719917120116\n64999889315593-65189382496202\n62511033442122-62882231057991\n169629548448978-169629548448978\n195991726717561-200347594718591\n80800364897743-82410540424990\n157966143122749-158625789879543\n414893276002289-420734433214551\n468854880571347-470178150823398\n293047529057561-293047529057561\n526293793744803-526800435871324\n154610263545675-155018832807006\n85676500485010-87494001551296\n404052468013478-411059540873663\n529805857574316-530354749652142\n282126028703430-287392631951184\n536612716581558-542001885354658\n224389325429033-225956850054114\n389327354686290-389941649666180\n226458176996215-227998751964573\n466681105242973-468035461798180\n132182495488136-136864510598769\n158625789879543-158943957000511\n222498723695457-223722626496659\n24396986945805-29009989981082\n387070084421471-387699738663307\n463761550427134-465101663712718\n244484473250009-249824444617715\n235682381324440-239428507922589\n356542431952285-357218504633271\n528809160802420-529163494010802\n203275761047276-207893046967514\n65189382496202-65740304733466\n84564501332038-86342507935742\n528809160802420-529739126171581\n430824287436458-430824287436458\n270464997549767-270464997549767\n73412860995201-73412860995201\n203275761047276-207893046967514\n465765531974637-467339424840641\n88308683283200-90314897336701\n506719917120116-509378158464998\n154610263545675-155018832807006\n436351058276905-441549428537929\n390250299542523-390501802123222\n464766089052130-465995972804612\n153723748856595-154247928476913\n524957458539564-525444885761624\n193355047594087-195991726717559\n68057027039766-68454649435444\n114292754379846-114292754379846\n476176387291714-479287347759176\n68727093315072-69054421292865\n374010991378735-378095042001312\n396702787271742-398555495412596\n92985559435331-99083983384255\n524317721420090-524645436296520\n470916081729043-472406223184007\n307193970359996-309957481846034\n83208072709351-85336482970086\n61908006035935-62767933777530\n12440214380075-19413829756369\n158268094987535-158625789879543\n323855611951188-327225842492665\n232121351950005-235682381324439\n104580961113313-109652180451852\n155719620755384-156378640409574\n225242642256272-226838958939168\n126345620041269-129628037616258\n272979306019768-272979306019768\n229571449179868-230955409924473\n15572428843108-19413829756369\n486438625661094-489174884685392\n399063478386186-400626043814074\n61434917885505-61908006035935\n442807002499434-447467590937981\n153470274802250-153891356149723\n548528649335253-552132613556960\n302406550101741-307193970359994\n284836416410676-290905691766532\n134736737710827-138821293926430\n524645436296520-525444885761624\n347299925469182-350731461622425\n333121507005172-333121507005172\n257633973479609-259311991697339\n418350619486212-420734433214551\n523873015780814-524032209716334\n424331863324814-430824287436457\n143154545648377-148152467497972\n156770859353106-157228370844559\n523401105399726-524032209716334\n3672218268426-9069958349825\n41190120499524-48710502110828\n171431709160547-176780839877720\n65740304733466-66283299959280\n3672218268426-9069958349825\n157444284967581-157743465985657\n99083983384256-99083983384256\n114292754379847-118122243442587\n32783805912506-34889394659117\n495774309849622-495774309849622\n385597213338484-386130309524989\n66422129062863-66711994098586\n390501802123222-390843409397977\n227420995218497-229137292369316\n518765954978807-520809013033287\n81872566000969-83813851796454\n272979306019768-280055074059068\n394469512488834-396279958092492\n469546011173175-471346897231698\n442807002499434-451270889383530\n184738598610317-187210601572675\n364359970290004-369109081626630\n327225842492665-327225842492665\n353087698181504-361406479744402\n293047529057561-299710639297794\n486438625661094-489174884685392\n472788183962691-480272823246663\n152000130191943-152486238796869\n386858817856261-387699738663307\n462503261552047-464039809812541\n183175626133351-189172211000972\n163807315460788-169629548448978\n393534536834350-394918686174827\n344389995827602-347299925469181\n159774306485562-160419960771595\n544514849402253-552132613556960\n65400483278322-66283299959280\n63641646788533-63945948546021\n228387323493940-230123402570745\n223334527687062-225118219054282\n398001413033472-399528430973758\n389120143291068-389327354686290\n251886663550811-259311991697339\n69054421292865-69216943568303\n109652180451852-109652180451852\n53011962076696-56344039055008\n400162615237818-402020110303086\n43204303716398-46879070810322\n314744608126757-318669297711175\n432956413748504-436351058276903\n374010991378735-379580541653265\n53011962076696-58576758868523\n151246265148187-151690444980057\n67160465476009-67649438641309\n333121507005173-341135415342898\n456177793236387-461879349449355\n395508284503006-397494347386228\n533093622413503-538889692659981\n561794342755365-561794342755365\n515616143391792-518765954978806\n69696292125615-70040914201079\n68727093315072-69401400390266\n495774309849623-500237151028475\n369109081626631-369109081626631\n529163494010802-529436944344583\n404052468013478-411059540873663\n121847024509459-126345620041267\n522880293422404-523179474172233\n158459878825465-159131956260867\n213743501161201-219471291456959"

type Ranges struct {
	start, end int
}

var m []Ranges

// Это часть 2, часть 1 была утеряна но она довольно лёгкая
func main() {
	ranges := strings.Split(g, "\n")

	for _, v := range ranges {
		fillMap(v)
	}

	var count int
	for _, v := range m {
		tmpCount := count
		c := v.end - v.start
		c += 1
		count += c
		if tmpCount > count {
			panic("count")
		}
	}
	fmt.Println(count)
}

func fillMap(s string) {
	split := strings.Split(s, "-")
	if len(split) != 2 {
		panic("unreal engine?")
	}

	start, err := strconv.Atoi(split[0])
	if err != nil {
		panic(err)
	}
	end, err := strconv.Atoi(split[1])
	if err != nil {
		panic(err)
	}

	// 	se		    18 19 20
	//	v	  16 17 18 19 20 21 22
	haveFullOverlaps := func() (int, bool) {
		for idx, v := range m {
			if v.start <= start && end <= v.end {
				return idx, true
			}

			// se 0 1 2 3 4 5
			// v        3 4 5
			if start <= v.start && end >= v.end {
				return idx, true
			}
		}
		return 0, false
	}

	// 	v		             15 16 17
	//	se 10 11 12 13 14
	havePatiralOverlaps := func() (int, bool) {

		for idx, v := range m {
			if v.start >= start && end <= v.end && v.start <= end {
				return idx, true
			}

			if v.start <= start && end >= v.end && v.end >= start {
				return idx, true
			}

		}
		return 0, false
	}

	for {
		idx, ok := haveFullOverlaps()
		if !ok {
			break
		}

		v := fullOverlap(m[idx], start, end)
		if v == 1 { // 1 - дропаем текущй range в массиве
			m = append(m[:idx], m[idx+1:]...)
		}
		if v == 2 { // 2 - не надо добавлять текущий start,end в массив
			return
		}
		if v == 0 {
			return
		}

	}

	for {
		idx, ok := havePatiralOverlaps()
		if !ok {
			break
		}
		start, end = partOverlap(m[idx], start, end)
	}

	m = append(m, Ranges{start, end})
}

// возвращает новые start, end
// основная идея что если есть какое то перекрытие с r
// то надо оберзать start,end и добавить их в []r
//
//	r		15 16 17 18 19 20
//	se	  				19 20 21
func partOverlap(r Ranges, start, end int) (int, int) {
	if r.start <= start && r.end <= end {
		//	r		15 16 17 18 19 20
		//	se	  				19 20 21
		return r.end + 1, end
	}

	if start <= r.start && end <= r.end {
		//	r		15 16 17 18 19 20
		// se 13 14 15 16
		return start, r.start - 1

	}
	panic("unreachable")
	return -1, -1
}
func fullOverlap(r Ranges, start, end int) int {
	// если r внутри start end
	t11 := r.start >= start && r.start <= end
	t12 := r.end >= start && r.end <= end
	if t11 &&
		t12 {
		return 1
	}

	// если start и end внутри r Range
	t21 := start >= r.start && start <= r.end
	t22 := end >= r.start && end <= r.end
	if t21 &&
		t22 {
		return 2
	}

	return 0
}
